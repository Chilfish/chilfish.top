---
title: 数据结构 (C++ 描述)
date: 2022-10-08
tags: [Algorithm, DS]
---

:::info
**主要参考书：** [数据结构与算法分析 C++语言描述第四版 —— Mark Allen Weiss（电子工业出版社）](https://book.douban.com/subject/30393441/)
:::

:::tip
在设计上更多地参考了 C++的 [STL 标准库容器](../STL.md) ）模仿 -> 尽头都是手搓个低配版 STL 了）
:::

- **线性结构**
  - [数组、栈、队列](LinearList.md)
  - [链表 Linked List](LinkedList.md)
  - [字符串 String](#)
- **非线性结构结构**
  - [树 Tree](Tree.md)
  - [散列表 Hash](#)
  - [堆 Heap](#)
  - [图 Graph](#)

## 基本概念

数据是存储在计算机内存里的，在存储时决定了数据的顺序和位置关系的就是“数据结构”

数据结构是数据元素间逻辑关系的表示，是计算机中存储与组织数据的方式。计算机主存储器中特定数据结构的表示称为 _存储结构_，辅助(外)存储器(如硬盘、U 盘等)中的存储结构表示称为 _文件结构_

### 什么是数据

数据是描述客观事物的符号，可被计算机读取、识别、处理。与数据相关的重要概念有以下几个：

- **数据元素(data element)：** 组成数据的基本单位，在程序中通常作为一个整体进行考虑和处理，也被称为记录
- **数据项(data item)：** 具有独立含义的最小标识单位。例如，一条数据记录可以称为一个数据元素，数据记录的某个字段就是一个数据项
- **数据对象(data object)：** 性质相同的数据元素的集合，是数据的一个子集
- **数据结构：** 相互之间存在一种或多种特定关系的数据元素的集合。数据结构包含三方面：**数据的逻辑结构、数据的存储结构和数据的运算**

例：在一张用户表中，一行记录就是一个 _数据元素_，用户的姓名就是一个 _数据项_，年龄条件大于 20 的用户就是一个 _数据对象_，是整个用户表的子集。在实际应用中，可以将数据对象简称为 _数据_

### 数据的分类

在计算机或普遍的的编程语言中，数据通常分为两大类： **原始数据结构**、**非原始数据结构**

![计算机内的数据分类](/blog/algo/DS_base.png)

#### 原始数据结构的特点

- 原始数据结构是计算机的基本结构，可通过机器指令直接操作
- 这些数据类型在大多数编程语言中都是内置类型
- 而保存另一个变量的 **内存地址** 的变量称为指针

#### 非原始数据结构的特点

- 从原始数据结构派生，数据结构更复杂
- 非原始数据类型根据结构进一步分为线性和非线性数据结构
  - 数组(线性)：数组是相同数据类型的元素的固定大小的有序序列集合
  - 列表(线性-链表)：包含可变数量元素的有序集合称为列表
  - 文件(非线性-树)：文件是逻辑相关信息的集合。可以将其视为包含各个字段的大型记录列表

### 数据类型的分类

## 数据结构的分类

数据结构分为逻辑结构和物理结构

- **逻辑结构：** 指数据元素之间逻辑关系的数据结构，这里的逻辑关系是指数据元素之间的前后间关系，与数据在计算机中的存储位置无关
- **物理结构：** 指数据的逻辑结构在计算机存储空间中的存放形式称为数据的物理结构，也叫做**存储结构**

### 按逻辑结构分类

数据的逻辑结构主要分为线性结构和非线性结构

- **线性结构：** 数据结构的元素之间存在一对一的 **线性关系**，所有结点都最多只有一个直接前趋结点和一个直接后继结点。常见的有数组、队列、链表、栈

- **非线性结构：** 各个结点之间具有多个对应关系，一个结点可能有多个直接前趋结点和多个直接后继结点。常见的有多维数组、广义表、树结构和图结构等

<div class="tableBox">

<span></span>
线性数据结构 | 非线性数据结构
| :- | :- |
数据元素以线性顺序排列，其中每个元素都附加到其上一个和下一个相邻元素 | 数据元素以分层方式附加
所有数据元素在同一层级 | 数据元素涉及多个层级
单次运行即可遍历所有数据元素 | 单次运行难以遍历所有数据元素
没有以有效的方式利用存储器| 有效方式利用存储器

</div>

### 按储存结构分类

数据的物理结构（存储结构），**表示数据元素之间的逻辑关系**，一种数据结构的逻辑结构根据需要可以表示成多种存储结构，常用的存储结构有：

- **顺序存储：** 存储顺序是连续的，在内存中用一组 **地址连续的存储单元**依次存储线性表的各个数据元素

  - 优点：节省存储空间，只需要存储数据节点，不需存储节点间的逻辑关系
  - 缺点：插入和删除元素需要移动元素，效率低下

- **链式存储：** 在内存中的存储元素不一定是连续的，用任意地址的存储单元存储元素，元素节点存放数据元素以及 **通过指针指向相邻元素的地址信息**

  - 优点：便于修改，修改时只需要修改数据节点的指针指向，不需要移动其它节点
  - 缺点：存储空间利用率低，需额外空间存储数据节点间的逻辑关系。因为结点之间不一定相邻，因此不能对结点进行随机访问
    > 随机访问（亦称随机存取、直接访问）指数据被读取或写入时，**所需要的时间与这段数据所在的存储位置无关**。链表只能顺序访问，从链表的第一个数据元素开始顺序读取，而无法像数组一样根据下标获取指定数据

- **索引存储：** 索引存储结构在存储数据元素的同时，还建立附加的 **索引表**。索引表中的每一项称为索引项，索引项的形式为 `(关键字，地址)`，关键字用于标识数据元素，地址为数据指针。各结点的地址在索引表中是依次排列的

  - 优点：可以快速查找，可以随机访问，方便修改
  - 缺点：建立索引表增加了时间和空间的开销

- **散列存储：** 散列存储结构是根据结点的值确定结点的存储地址。以结点作为自变量，通过散列函数算出结果 i，再把 i 作为结点的存储地址，故又称为 `Hash 存储`
  - 优点：查找速度快，适用于快速查找和插入的场景
  - 缺点：只存结点数据，不存结点之间的关系

> 为什么一堆“教程”一上来就都是直接的 复杂度 $\to$ 数组 $\to$ 链表 $\dots$，都跳过了概念呢……

## 迭代器

在想要遍历或访问数据结构中的数据时，一方面希望只使用共有的方法就能遍历，另一方面又希望能够统一各个数据结构的遍历方式，于是就有了 **迭代器**

就如，`std::vector` 是用数组实现的，`std::list`使用链表实现的，`std::map`则是红黑树实现，每个 **容器** 的遍历方式都不一样，遍历的边界也都不一样，这时候就需要迭代器去统一

而对表的一些操作，尤其是在表的中间进行插入和删除的操作，需要位置的概念。在 STL 中位置由内嵌的 `iterator` 表示。它定义了一对方法：

- `iterator begin()`：表示容器|表的第一项
- `Iterator end()`：表示容器|表最后一项之后的位置

使用迭代器对表的遍历，即为从表头一直到表尾。如：

```cpp
for (vector<int>::iterator it = arr.begin(); it != arr.end(); ++it) {
  std::cout << *it << " ";
}
```

#### 一些对迭代器的操作

- `++it` 和 `++it`：将迭代器推到下一个位置
- `--it` 和 `it--`：将迭代器推到上一个位置
- `it1 == it2` 和 `it1 != it2`：比较是否指向同一个位置
- `*it`，返回迭代器指向数据的引用
- `It + n` 和 `it - n`：将迭代器向前或向后推 n 个位置

其中，对于数据的访问有两种情况：只读或读写：`const_iterator` 表示只读迭代器，不允许改写指向元素的值， `iterator` 则是可读写迭代器

<details>
<summary>一个双向迭代器</summary>

```cpp
template<class T>class xxx {
private:
  // 或是其他的内部的数据结构
  typedef Node int;
public:
  // 只读迭代器，不能改写指向元素的值
  class const_iterator {
  protected:
    Node *cur; // 指迭代器当前指向的元素
    int index; // 记录迭代器当前指向的线性结构的“下标”
    const xxx<T> *thisList; // 指向迭代器本身的对象的指针
    friend class xxx<T>; // 向本对象声明友元

    const_iterator(const xxx<T> &l, Node *p)
      :thisList{&l}, cur{p}, index{0} {}

    // 判断迭代器是否失效
    void assertValid() const {
      if (cur == nullptr || thisList == nullptr
        || cur == thisList->head)
        throw IteratorError();
    }

    // 返回当前迭代器指向元素的值
    T &getData() const {
      assertValid();
      return cur->data;
    }

  public:
    // 重载 *以访问值
    const T &operator*() { return getData(); }
    // 向前推进迭代器
    const_iterator &operator++() {
      if (cur->next == nullptr) {
        throw IteratorError();
      }
      cur = cur->next;
      ++index;
      return *this;
    }
    const_iterator operator++(int) {
      const_iterator old = *this;
      ++(*this);
      return old;
    }
    // 向后推进迭代器
    const_iterator &operator--() {
      if (cur->prev == nullptr) {
        throw IteratorError();
      }
      cur = cur->prev;
      --index;
      return *this;
    }
    const_iterator &operator--(int) {
      const_iterator old = *this;
      --(*this);
      return old;
    }
    // 迭代器向前推进x位
    const_iterator &operator+(int x) {
      while (x--) ++(*this);
      return *this;
    }
    // 迭代器向后推进x位
    const_iterator &operator-(int x) {
      while (x--) --(*this);
      return *this;
    }
    // 返回两个迭代器之间的距离
    int operator-(const const_iterator &x) {
      return index - x.index;
    }
    // 判断两个迭代器是否相等
    bool operator==(const const_iterator &rhs) const {
      return cur == rhs.cur;
    }
    bool operator!=(const const_iterator &rhs) const {
      return !(*this == rhs);
    }
  };
};
```

</details>
