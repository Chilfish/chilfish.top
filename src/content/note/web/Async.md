---
title: 同步、异步与阻塞、非阻塞
date: 2022-10-16
tags: [js]
---

## 概述

### 经典故事

老张有两个水壶：普通水壶、烧开后会响的水壶

- **同步阻塞：** 老张把水壶放到火上，立等水开
- **同步非阻塞：** 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有
- **异步阻塞：** 老张把响水壶放到火上，立等水开
- **异步非阻塞：** 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶

**所谓同步异步，只是对于水壶而言**。 普通水壶，同步；响水壶，异步

- 虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了（**完成后的消息**）
- 同步只能让调用者去 **轮询** 自己，造成老张效率的低下

**所谓阻塞非阻塞，仅仅对于老张而言**。 干等的老张，阻塞；看电视的老张，非阻塞

- 情况 1 和情况 3 中老张就是阻塞的，只能等当前事件完成后才能干别的，媳妇喊他都不知道
- 虽然 3 中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般**异步是配合非阻塞使用的**，这样才能发挥异步的效用

### 阻塞与非阻塞

阻塞和非阻塞是从 **程序（线程）等待消息通知（无所谓同步或者异步）时的状态** 的角度来说的，关注的是程序在等待调用结果（消息、返回值）时的状态

- **阻塞调用** 是指调用结果返回之前，当前线程会被**挂起**，专注于完成当前线程。调用线程只有在等到结果之后才会返回
- **非阻塞调用** 指在不能立刻得到结果之时，该调用不会阻塞当前线程，而是可以继续执行别的进程

### 同步与异步

#### 同步

所谓同步，就是发出一个功能调用时，在得到结果之前，该调用就不返回或继续执行后续操作。 简单来说，**同步就是必须一件一件事做，等前一件做完了才能做下一件事**

> 例如：B/S 模式中的表单提交，具体过程是：客户端提交请求->等待服务器处理->处理完毕返回，在这个过程中客户端（浏览器）不能做其他事

#### 异步

异步与同步相对，当一个异步过程调用发出后，调用者在得到结果之前，就可以继续执行后续操作。调用者一般通过状态、通知和回调来了解调用的执行情况：

- **状态：** 即监听被调用者的状态（**轮询**），调用者需要每隔一定时间检查一次，效率会很低
- **通知：** 当被调用者执行完成后，发出通知告知调用者，无需消耗太多性能
- **回调：** 与通知类似，当被调用者执行完成后，会调用调用者提供的回调函数

> 例如：B/S 模式中的 ajax 请求，具体过程是：客户端发出 ajax 请求->服务端处理->处理完毕执行客户端回调，在客户端（浏览器）发出请求后，仍然可以做其他的事

#### 场景

假设有多个耗时的操作，如果都用同步的方式去运行，那总的耗时就是**所有耗时的和**；但如果用异步的方式去运行，那总的耗时就是当中**最大的耗时**

同步就在于为了**按代码编写的顺序**去执行，而异步就是为了**按时间的顺序**去执行

## JavaScript 实现异步的方案

众所周知， Javascript 语言的执行环境是 “单线程”，也就是**指一次只能完成一件任务**。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务

这种模式虽然实现起来比较简单，执行环境相对单纯，但是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。**此时解决任务的总时长为所有任务时长的和**

如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 操作（输入输出）很慢（比如 Ajax 操作从网络读取数据），**不得不等着结果出来，再往下执行**

> 常见的浏览器无响应（假死），往往就是因为某一段 Javascript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行

但其实这时候 CPU 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的 “事件循环”机制（Event Loop）

在通常情况下，JavaScript 是可以同步地按顺序执行的，但一旦涉及了 `setTimeout`、文件 IO、网络请求等操作，JavaScript 就会把他们当做异步了。这时，它会先把异步的函数推入一个任务队列中，等所有同步的函数执行完后再执行异步的，耗时为 $O(max(\text{异步时间}))$。如

```js
function c(data) {
  setTimeout(() => {
    data += 100
  }, 1000)
  return data
}

const aa = 23
console.log(c(aa)) // 设想是先执行c里的 += 100 再输出
// 但输出 b: 23
```

原因就在于函数 c 中的 `setTimeout` 导致了这个语句被放到了异步队列，在 `data += 100` 之前就直接 `return data;` 了，所以就还是输出了 23

但实际上设想的是 **按时间顺序** 地 1 秒后 += 100，再返回。所以，当使用了异步操作的时候，就要用专门的异步的方式去执行。通常有以下几种来实现异步：

### 回调函数
